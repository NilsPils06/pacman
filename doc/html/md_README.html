<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pacman Project: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Pacman Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md_README.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">README </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Name: Nils Van de Velde</p>
<p>Studentnumber: 20240345</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md2"></a>
ðŸ“‹ Project Evaluation Checklist</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md3"></a>
1. Core Game Requirements (40 Points)</h3>
<ul class="check">
<li class="checked"><b>Startup screen &amp; Scoreboard</b><ul>
<li><em>Implementation:</em> Startup screen is implemented in de <a class="el" href="classMenuState.html">MenuState</a>, where the play button is created in the constructor and the scores are loaded via a json file. After that the render function creates a static title, playTexts and inputText so that they are only created once. The render function draws the text to the screen and calls renderScoreboard() which creates a sorted vector of the scores (pair&lt;string, int&gt;) and draws the top 5 with 40 pixels height difference between every score.</li>
</ul>
</li>
</ul>
<ul class="check">
<li class="checked"><b>Maze &amp; Collision Correctness</b><ul>
<li><em>Implementation:</em> Mazes are implemented via txt files and are read in the <a class="el" href="classWorld.html">World</a> constructor. <a class="el" href="classWorld.html">World</a> checks for collisions every tick but it doesn't check for collisions with walls. The movement code (found in tick()) of pacman and the ghost prevent them (mostly) from running against walls. <a class="el" href="classWorld.html">World</a> gives them a wallValidator function ( via std::function) so that they are aware of where the walls are. Using this system I don't need to check for intersecting rectangles with walls.</li>
</ul>
</li>
</ul>
<ul class="check">
<li class="checked"><b>Smooth Continuous Movement</b><ul>
<li><em>Implementation:</em> The movement of Pacman is handled by the tick function, where its speed is dynamically adapted based on direction and deltaTime. A wallValidator ensures that Pacman cannot move into walls, and queued directions are processed to enable seamless turns. The alignToCenter helper function keeps Pacman centered within grid cells, while a correction speed prevents abrupt stops when movement constraints are met. This implementation achieves smooth and continuous movement across varying directions while avoiding jittery behavior during transitions between tiles.</li>
</ul>
</li>
</ul>
<ul class="check">
<li class="checked"><b>Ghost AI</b><ul>
<li><em>Modes Implemented:</em> Fear, Eaten, Chasing, Waiting.</li>
<li><em>Logic:</em> Ghosts use BFS and manhattan distance to determine which direction they should go to, depending on the movement type. You have 2 Cutting type ghosts, which look 4 tiles ahead of pacman and then uses BFS to determine the best direction to go to, if this fails we use Manhattan distance as a fallback. The remaining 2 ghosts are the Fixed and Chasing ghosts. The Chasing ghost uses the same system as the Cutting ones, without the lookahead and the Fixed ghost chooses a random index from a vector of candidates. The chasing mode/boolean is only used for the delay of the ghosts. The eaten mode/boolean is used to change their target in BFS/Manhattan to their spawn location and to update their sprite. Fear mode will be discussed later.</li>
</ul>
</li>
</ul>
<ul class="check">
<li class="checked"><b>Coin &amp; Fruit <a class="el" href="classScore.html">Score</a> Modifiers</b><ul>
<li><em>Implementation:</em> When a collision with a Collectable and Pacman is detected, score is notified via a <a class="el" href="classCollectEvent.html">CollectEvent</a>, which tells the score how many points it should add. The score also calculates a bonus with the following formula using base as the points from the collectable: min(base / (timeSinceCollection + 0.1f), base). We add 0.1 to avoid division by 0, even though it shouldn't take place in a normal game. The bonus is capped at base, so you can maximally reach a 100% bonus. Coins are worth 10 points, fruit is 100 points and ghosts are 200. Since the bonus is calculated using the points of the current collected collectable, it is better to eat a lot of coins right before collecting fruit or ghosts.</li>
</ul>
</li>
</ul>
<ul class="check">
<li class="checked"><b>Fear Mode &amp; Ghost Reversal</b><ul>
<li><em>Implementation:</em> Just like wall detection a ghostFearer function is given to the pacmanCollisionHandler, so that when pacman collects a fruit, the handler can set the ghosts to fear mode without knowledge of the ghosts themselves. When the ghosts are in fear mode they all use Manhattan distance to run away from pacman using the boolean maximize. We call the same function but tell it to maximize the distance via this maximize boolean.</li>
</ul>
</li>
</ul>
<ul class="check">
<li class="checked"><b>Level Clearing &amp; Scaling Difficulty</b><ul>
<li><em>Implementation:</em> A level is cleared when all collectables are collected. This is detected in <a class="el" href="classWorld.html">World</a> simply by checking if the collectables vector is empty. Every tick we check if a collectable is marked as expired (the marking of expired happens on collision with pacman), and if it is expired we remove from the vector and decouple it's observers, so that the observers don't try to observe a non-existing object. When a level is cleared we increment the level counter in <a class="el" href="classLevelState.html">LevelState</a> and make a new world and give it the new level. I have a system in place so that you can use different maps, but I don't use it myself. The ghosts have level as a member and use it to calculate fear duration: 5 - 0.5 * (level - 1) and speed: 0.3 + 0.05 * (level - 1). You start at level 1 and there is technically no limit to which level you can reach, except of course integer limit. This combined with the smart movement of the ghosts make higher levels really difficult (at the time of writing this I haven't reached level 2 yet). After every level completion you get a quick win screen via <a class="el" href="classVictoryState.html">VictoryState</a>, which shows which level you cleared.</li>
</ul>
</li>
</ul>
<ul class="check">
<li class="checked"><b>Life System &amp; <a class="el" href="classGame.html">Game</a> Over</b><ul>
<li><em>Implementation:</em> You have 3 lives and when you hit a ghost, you lose one and then pacman and ghost positions are reset directly after the death animation. During the death animation only pacman, score and lives are rendered and ticked. Lives reset to 3 after every level. After you lose all 3, detected by world via pacmanCollisionHandler, you go to the <a class="el" href="classDefeatState.html">DefeatState</a> where you can return to menu and your score is saved to the json.</li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md4"></a>
2. Software Design &amp; Code Architecture (40 Points)</h3>
<ul class="check">
<li class="checked"><b>Clear MVC Separation</b><ul>
<li><em>Implementation:</em> In src you have the EntityViews which have all sprite data and get other data from EntityModels via Events and the notify function. The notification of events often happen in the tick functions of EntityModels, <a class="el" href="classWorld.html">World</a> or a collision handler. Thus, EntityView is the view, EntityModel is the Model and <a class="el" href="classWorld.html">World</a> (which calls the tick functions) and <a class="el" href="classPacmanCollisionHandler.html">PacmanCollisionHandler</a> are the controllers.</li>
</ul>
</li>
</ul>
<ul class="check">
<li class="checked"><b>Design Patterns Implemented</b><ul>
<li><b>MVC:</b> Explained above.</li>
<li><b><a class="el" href="classObserver.html">Observer</a>:</b> Observers use the update function to handle their own logic based on events. For example: PacmanView updates it's sprite according to a <a class="el" href="classTickEvent.html">TickEvent</a> which tells it where to display pacman and which way he's facing.</li>
<li><b>Abstract Factory:</b> Abstract Factory consists of createEntity functions which are then implemented in its subclass <a class="el" href="classEntityFactory.html">EntityFactory</a>.</li>
<li><b>Singleton:</b> I used the singleton pattern for <a class="el" href="classRandom.html">Random</a> and <a class="el" href="classStopwatch.html">Stopwatch</a>. I had discussed with classmates about making <a class="el" href="classCamera.html">Camera</a> a singleton, but since my <a class="el" href="classCamera.html">Camera</a> doesn't have any member variables, it only contains static functions. The way I implemented the Singleton pattern was by deleting the constructors and using a unique_ptr as the instance. When you call getInstance a reference to the object is returned.</li>
<li><b><a class="el" href="classState.html">State</a> Pattern:</b> I have a <a class="el" href="classStateManager.html">StateManager</a> which contains a stack of States via unique_ptr's and only the manager is able to call the update functions for input and rendering.</li>
</ul>
</li>
</ul>
<ul class="check">
<li class="checked"><b>Logic as Standalone Library</b><ul>
<li><em>Implementation:</em> My logic and library and representation (which I simply call src) have separate CMakeLists so that logic and src are compiled separately. Then I have a main CMakeList which links them together.</li>
</ul>
</li>
</ul>
<ul class="check">
<li class="checked"><b><a class="el" href="classCamera.html">Camera</a> &amp; Normalized Coordinates</b><ul>
<li><em>Implementation:</em> <a class="el" href="classCamera.html">Camera</a> consists of 3 static functions: showScore (displays score), showLives (displays lives) and project, which projects and entity to the screen by transforming the normalized coordinates to pixel coordinates. I do this by first calculating cell dimensions (<a class="el" href="structCoords.html">Coords</a> keep normalized width and height of the entity), we then calculate the center of the screen and an offset which we use to calculate the pixel x and y coordinates as follows: center_x + (coords.x * offset_x). To kind of translate this formula, the coordinates of a entity are always its center coordinates, so to project them to the screen we start at the center of the screen and calculate how much to the right/left and up/down we have to go to find its relative pixel coordinates.</li>
</ul>
</li>
</ul>
<ul class="check">
<li class="checked"><b>Polymorphism &amp; Extensibility</b><ul>
<li><em>Implementation:</em></li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md5"></a>
3. Documentation &amp; Deliverables (20 Points)</h3>
<ul class="check">
<li class="unchecked"><b>Project Defence Video</b><ul>
<li>[Gameplay Demo (3 min)](LINK_HERE)</li>
<li>[Technical Explanation (7 min)](LINK_HERE)</li>
</ul>
</li>
</ul>
<ul class="check">
<li class="unchecked"><b>Written Documentation</b><ul class="check">
<li class="unchecked">2-Page Report &amp; Design Rationale</li>
</ul>
<ul class="check">
<li class="checked">Doxygen/API Documentation (Comments in code)</li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6"></a>
4. Bonus Features (Up to 10 Points)</h3>
<ul class="check">
<li class="unchecked"><b>Extra Gameplay / Visuals</b></li>
</ul>
<ul class="check">
<li class="unchecked"><b>Sounds / Music</b></li>
</ul>
<ul class="check">
<li class="checked"><b>Smarter AI (BFS / <strike>A</strike> * )</b></li>
<li class="unchecked"><b>Procedural Maps</b></li>
</ul>
<ul class="check">
<li class="unchecked"><b>Multithreading</b></li>
</ul>
<ul class="check">
<li class="checked"><b>Extra Design Patterns</b><ul>
<li><em>Details:</em> Visitor pattern for Collision </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
